# 1주차 과제

## Class loader

자바 클래스를 동적으로 JVM으로 읽어드리는 자바 런타임 (JRE)의 일부

>### Class loader의 계층 구조
>
>1. 부트스트랩 클래스 로더: <JAVA_HOME>/jre/lib 디렉터리에 위치한 핵심 자바 라이브러리들을 불러들인다
>2. 확장 클래스 로더: 확장 디렉터리(<JAVA_HOME>/jre/lib/ext 또는 java.ext.dirs 시스템 속성에 지정된 기타 디렉터리)에 코드를 로드한다
>3. 시스템 클래스 로더: java.class.path에서 볼 수 있는 시스템 클래스 로더는 CLASSPATH 환경 변수에 매핑된다

---

## 메모리 구조

프로그램을 구동하기 위해서 운영체제가 메모리(RAM)에 데이터 및 명령어를 저장할 공간을 할당하여 준다. 메모리에는 크게 3가지 종류의 공간이 있는데 저장할 데이터에 따라서 각각 다른 영역에 저장이 된다.

### 1. Static area

 하나의 JAVA 파일은 크게 필드(field), 생성자(constructor), 메소드(method)로 구성된다. 그중 필드 부분에서 선언된 변수(전역변수)와 정적 멤버변수(static이 붙은 자료형) Static 영역에 데이터를 저장한다. Static 영역의 데이터는 프로그램의 시작부터 종료가 될 때까지 메모리에 남아있게 된다. 다르게 말하면 전역변수가 프로그램이 종료될 때까지 어디서든 사용이 가능한 이유이기도 하다.

### 2. Stack area

우리가 현재까지 작성하던 메소드 내에서 정의하는 기본 자료형(int, double, byte, long, boolean 등)에 해당되는 지역변수(매개 변수 및 블럭문 내 변수 포함)의 데이터의 값이 저장되는 공간이 Stack(스택) 영역이다. 해당 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다.

### 3. Heap area

참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스), 배열 등은 Heap 영역에 데이터가 저장된다. 이때 변수(객체, 객체변수, 참조변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조값(reference value, 해시코드 / 메모리에 저장된 주소를 연결해주는 값)을 new 연산자를 통해 리턴 받는다. 다시 말하면 실제 데이터를 갖고 있는 Heap 영역의 참조 값을 Stack 영역의 객체가 갖고 있다. 이렇게 리턴 받은 참조 값을 갖고 있는 객체를 통해서만 해당 인스턴스를 핸들 할 수 있다.

> 메모리 구조 [출처](http://blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220954420688)

---

## AOP

기능을 핵심 비즈니스 로직과 공통 모듈로 나누고 비즈니스 로직에 영향을 미치지 않으면서 공통 모듈을 같이 수행할 수 있는 개발 방법. 활용 예제는 로깅, 인증, 권한 관리 등이 있다

![img](https://t1.daumcdn.net/cfile/tistory/11110A0C4AA116EE33)

---

## Proxy

프록시는 실제로 액션을 취하는 객체를 대신해서 대리자 역활을 해준다. 프록시 패턴을 사용하게 되면 프록시 단계에서 권한을 부여할 수 있는 이점이 생기고 필요에 따라 객체를 생성시키거나 사용하기 때문에 메모리를 절약할 수 있는 이점도 생긴다. 프록시 패턴이 하는 일은 한마디로 자신이 보호하고 있는 객체에 대한 액세스 권한을 제어하는 것이다.

![img](https://t1.daumcdn.net/cfile/tistory/275FCE5054CE384F13)

---

## Thread and shared resources

수업을 안들어서 어떤걸 알아봐야할지모르겠다...
아마도 웹서블릿은 리퀘스트가 하나 들어올 때 마다 하나의 새로운 쓰레드가 생성되서 요청에 대한 응답 까지 쭉 처리 하기 때문에 공용으로 어떤걸 지속적으로 사용하려면 thread-safe하게 코드를 작성해야한다 이런 내용이 나와야하지 않을까

> 관련해서 잘 정리해 놓은 블로그 참고 [링크](http://tutorials.jenkov.com/java-concurrency/index.html) (매우 김 주의!)

---

## 빌드도구

Java에 대표적인 빌드 자동화 도구에는 Gradle과 Maven이 있다.

>### Gradle
>
>- 빌드 스크립트는 Groovy 또는 Kotlin DSL을 사용한다
>- 여러 프로젝트를 동시에 빌드하는 것을 지원하도록 디자인 되었다
>- 그래서 실제 변경이된 프로젝트를 캐치해서 해당 프로젝트만 빌드하기 때문에 이 경우 Maven보다 빌드 속도가 빠르다
>- 사실 빌드 타임 비교해보면 gradle의 빌드 캐싱을 켜두면 Maven에 비해 월등히 빠르다
>- 자바 말고도 다른 언어에 대한 빌드도 지원한다. 대표적으로 Android도 있다 (이건 언어가 아니잖어...)

>### Maven
>
>- 오래된 만큼 여러 IDE와의 호환성 등이 좋다
>- 물론 다른 언어 빌드를 지원하지만 대부분 자바 빌드를 위해 사용한다

[속도 비교 관련 자료](http://bkim.tistory.com/13)

---

## Maven CoC란?

*Convention over configuration*

관습적으로 사용되어지는 수많은 설정들을 default값으로 제공해서 개발자들로 하여금 프로젝트 설정에 들이는 시간과 노력을 줄여주고, 또한 설정을 공통적으로 사용함으로서 유연성과 단순성을 잃어버리지 않도록 하기 위한 소프트웨어 디자인 패러다임

CoC가 적용된 maven은 설정값을 변경하지 않는다면,

소스코드는 ${basedir}/src/main/java 에  
리소스들은 ${basedir}/src/main/resource 에  
테스트코드들은 ${basedir}/src/test 에  
프로젝트 파일은 ${basedir}/target 에  
JAR 파일로 제공된다  

Maven의 강점은 CoC를 거의 강요하는데서 온다. 기본 설정을 변경하지 않는 한 메이븐은 개발자에게 설정에 필요한 노력을 거의 요구하지 않는다.

> [출처](https://eminentstar.github.io/2017/07/07/about-maven.html)