# 1주차 과제

## Class loader

자바 클래스를 동적으로 JVM으로 읽어드리는 자바 런타임 (JRE)의 일부

>### Class loader의 계층 구조
>
>1. 부트스트랩 클래스 로더: <JAVA_HOME>/jre/lib 디렉터리에 위치한 핵심 자바 라이브러리들을 불러들인다
>2. 확장 클래스 로더: 확장 디렉터리(<JAVA_HOME>/jre/lib/ext 또는 java.ext.dirs 시스템 속성에 지정된 기타 디렉터리)에 코드를 로드한다
>3. 시스템 클래스 로더: java.class.path에서 볼 수 있는 시스템 클래스 로더는 CLASSPATH 환경 변수에 매핑된다

---

## 메모리 구조

프로그램을 구동하기 위해서 운영체제가 메모리(RAM)에 데이터 및 명령어를 저장할 공간을 할당하여 준다. 메모리에는 크게 3가지 종류의 공간이 있는데 저장할 데이터에 따라서 각각 다른 영역에 저장이 된다.

### 1. Static area

 하나의 JAVA 파일은 크게 필드(field), 생성자(constructor), 메소드(method)로 구성된다. 그중 필드 부분에서 선언된 변수(전역변수)와 정적 멤버변수(static이 붙은 자료형) Static 영역에 데이터를 저장한다. Static 영역의 데이터는 프로그램의 시작부터 종료가 될 때까지 메모리에 남아있게 된다. 다르게 말하면 전역변수가 프로그램이 종료될 때까지 어디서든 사용이 가능한 이유이기도 하다.

### 2. Stack area

우리가 현재까지 작성하던 메소드 내에서 정의하는 기본 자료형(int, double, byte, long, boolean 등)에 해당되는 지역변수(매개 변수 및 블럭문 내 변수 포함)의 데이터의 값이 저장되는 공간이 Stack(스택) 영역이다. 해당 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다.

### 3. Heap area

참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스), 배열 등은 Heap 영역에 데이터가 저장된다. 이때 변수(객체, 객체변수, 참조변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조값(reference value, 해시코드 / 메모리에 저장된 주소를 연결해주는 값)을 new 연산자를 통해 리턴 받는다. 다시 말하면 실제 데이터를 갖고 있는 Heap 영역의 참조 값을 Stack 영역의 객체가 갖고 있다. 이렇게 리턴 받은 참조 값을 갖고 있는 객체를 통해서만 해당 인스턴스를 핸들 할 수 있다.

> 메모리 구조 [출처](http://blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220954420688)

---

## AOP

기능을 핵심 비즈니스 로직과 공통 모듈로 나누고 비즈니스 로직에 영향을 미치지 않으면서 공통 모듈을 같이 수행할 수 있는 개발 방법. 활용 예제는 로깅, 인증, 권한 관리 등이 있다

![img](https://t1.daumcdn.net/cfile/tistory/11110A0C4AA116EE33)

---

## Proxy

프록시는 실제로 액션을 취하는 객체를 대신해서 대리자 역활을 해준다. 프록시 패턴을 사용하게 되면 프록시 단계에서 권한을 부여할 수 있는 이점이 생기고 필요에 따라 객체를 생성시키거나 사용하기 때문에 메모리를 절약할 수 있는 이점도 생긴다. 프록시 패턴이 하는 일은 한마디로 자신이 보호하고 있는 객체에 대한 액세스 권한을 제어하는 것이다.

![img](https://t1.daumcdn.net/cfile/tistory/275FCE5054CE384F13)

---

## Thread and shared resources

- thread와 공용객체
- Gradle이 무엇인가? Maven이 무엇인가? 빌드도구
- Maven CoC란?